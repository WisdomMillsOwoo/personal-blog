{
  "data": [
    {
      "body": "<h2>The API That Started It All</h2>\n<p>Three years ago, I inherited a REST API that was... let's call it &quot;challenging.&quot; 200+ endpoints, inconsistent naming, no versioning strategy, and documentation that was more fiction than fact. Sound familiar?</p>\n<p>That experience taught me more about API design than any tutorial ever could.</p>\n<h2>What Actually Matters</h2>\n<p>After rebuilding that API and working on dozens of others, here's what I've learned actually moves the needle:</p>\n<h3>1. Consistency Over Cleverness</h3>\n<p>Your API doesn't need to be revolutionary. It needs to be predictable.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Good - boring but predictable</span>\n<span class=\"hljs-variable constant_\">GET</span> /users\n<span class=\"hljs-variable constant_\">POST</span> /users\n<span class=\"hljs-variable constant_\">GET</span> /users/:id\n<span class=\"hljs-variable constant_\">PUT</span> /users/:id\n<span class=\"hljs-variable constant_\">DELETE</span> /users/:id\n\n<span class=\"hljs-comment\">// Bad - clever but confusing</span>\n<span class=\"hljs-variable constant_\">GET</span> /people/list\n<span class=\"hljs-variable constant_\">POST</span> /people/create\n<span class=\"hljs-variable constant_\">GET</span> /person/:id\n<span class=\"hljs-variable constant_\">PUT</span> /person/:id/update\n<span class=\"hljs-variable constant_\">DELETE</span> /person/:id/remove\n</code></pre>\n<h3>2. Error Messages That Don't Suck</h3>\n<p>Your 400 responses should tell developers exactly what went wrong and how to fix it.</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;error&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;validation_failed&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;message&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;The request contains invalid data&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;details&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n    <span class=\"hljs-punctuation\">{</span>\n      <span class=\"hljs-attr\">&quot;field&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;email&quot;</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">&quot;code&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;invalid_format&quot;</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">&quot;message&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;Email must be a valid email address&quot;</span>\n    <span class=\"hljs-punctuation\">}</span>\n  <span class=\"hljs-punctuation\">]</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<h3>3. Pagination That Scales</h3>\n<p>Don't use offset-based pagination for large datasets. Cursor-based pagination is your friend.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// This will hurt at scale</span>\n<span class=\"hljs-variable constant_\">GET</span> /posts?page=<span class=\"hljs-number\">1000</span>&amp;limit=<span class=\"hljs-number\">20</span>\n\n<span class=\"hljs-comment\">// This won&#x27;t</span>\n<span class=\"hljs-variable constant_\">GET</span> /posts?cursor=eyJpZCI6MTIzNDU&amp;limit=<span class=\"hljs-number\">20</span>\n</code></pre>\n<h2>The Tools That Actually Help</h2>\n<ul>\n<li><strong>OpenAPI/Swagger</strong>: Not just for documentation. Use it to generate client SDKs and validate requests.</li>\n<li><strong>Postman Collections</strong>: Share them with your team. Keep them updated.</li>\n<li><strong>Rate Limiting</strong>: Implement it early, not when your servers are on fire.</li>\n</ul>\n<h2>The Mindset Shift</h2>\n<p>Stop thinking about APIs as technical contracts. Start thinking about them as user experiences for developers.</p>\n<p>Every endpoint is a conversation. Every response is feedback. Every error is an opportunity to help someone succeed.</p>\n<h2>What's Next?</h2>\n<p>GraphQL? gRPC? The next shiny thing?</p>\n<p>Maybe. But first, master the fundamentals. Build APIs that developers actually want to use. The technology will evolve, but good design principles are timeless.</p>\n<p>What's the worst API you've ever had to work with? I'd love to hear your horror stories (and how you survived them).</p>\n",
      "title": "Building Better APIs - Lessons from the Trenches",
      "date": "2025-01-15T05:00:00.000Z",
      "description": "After years of building and consuming APIs, here are the patterns that actually matter.",
      "isCompleted": true,
      "slug": "building-better-apis",
      "tags": [
        "software",
        "api",
        "backend",
        "best-practices"
      ]
    },
    {
      "body": "<h2>The Case of the Disappearing Data</h2>\n<p>It was 2 AM. The production database was missing 30% of yesterday's user registrations. No error logs. No alerts. The data had simply vanished.</p>\n<p>This is the story of how I learned to debug like a detective.</p>\n<h2>Elementary, My Dear Watson</h2>\n<p>Sherlock Holmes never said that famous line, but he did say something more useful: &quot;You see, but you do not observe.&quot;</p>\n<p>Most debugging fails because we jump to conclusions instead of gathering evidence.</p>\n<h3>The First Rule: Observe Everything</h3>\n<p>When that data went missing, my first instinct was to blame the obvious suspects:</p>\n<ul>\n<li>Database corruption</li>\n<li>Failed backup restore</li>\n<li>Malicious deletion</li>\n</ul>\n<p>I was wrong on all counts.</p>\n<p>Instead of theorizing, I should have started with observation:</p>\n<ul>\n<li>What data was missing?</li>\n<li>When did it disappear?</li>\n<li>What patterns existed in the missing records?</li>\n</ul>\n<h2>The Detective's Toolkit</h2>\n<h3>1. The Timeline</h3>\n<p>Every good detective story starts with establishing when things happened. In debugging, this means:</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># When did the problem start?</span>\ngrep <span class=\"hljs-string\">&quot;ERROR&quot;</span> app.log | <span class=\"hljs-built_in\">head</span> -1\n\n<span class=\"hljs-comment\"># What changed recently?</span>\ngit <span class=\"hljs-built_in\">log</span> --since=<span class=\"hljs-string\">&quot;2 days ago&quot;</span> --oneline\n\n<span class=\"hljs-comment\"># What was the system doing at that time?</span>\ngrep <span class=\"hljs-string\">&quot;2025-01-28 14:30&quot;</span> /var/log/syslog\n</code></pre>\n<h3>2. The Evidence Chain</h3>\n<p>Document everything. Screenshots, log snippets, error messages. Future you will thank present you.</p>\n<p>I keep a debugging journal:</p>\n<pre><code><span class=\"hljs-attribute\">14</span>:<span class=\"hljs-number\">30</span> - User reports missing data\n<span class=\"hljs-attribute\">14</span>:<span class=\"hljs-number\">35</span> - Confirmed: <span class=\"hljs-number\">847</span> records missing from users table\n<span class=\"hljs-attribute\">14</span>:<span class=\"hljs-number\">40</span> - <span class=\"hljs-literal\">All</span> missing records created between <span class=\"hljs-number\">14</span>:<span class=\"hljs-number\">00</span>-<span class=\"hljs-number\">15</span>:<span class=\"hljs-number\">00</span> yesterday\n<span class=\"hljs-attribute\">14</span>:<span class=\"hljs-number\">45</span> - Checking deployment logs from that timeframe...\n</code></pre>\n<h3>3. The Witness Interviews</h3>\n<p>Talk to people. The user who reported the bug often knows more than they realize.</p>\n<p>&quot;When did you first notice this?&quot;<br>\n&quot;What were you trying to do?&quot;<br>\n&quot;Has this happened before?&quot;</p>\n<h2>The Plot Twist</h2>\n<p>Back to my missing data mystery. After hours of investigation, I discovered the truth:</p>\n<p>A well-meaning teammate had written a &quot;cleanup script&quot; to remove test data. The script had a bug - it was using a date comparison that included production data created during our testing window.</p>\n<p>The data wasn't corrupted or maliciously deleted. It was methodically removed by our own code.</p>\n<h2>Common Detective Mistakes</h2>\n<h3>The Red Herring</h3>\n<p>Don't get distracted by coincidences. Just because the server restarted around the time of the bug doesn't mean the restart caused it.</p>\n<h3>The Usual Suspects</h3>\n<p>We tend to blame the same things over and over:</p>\n<ul>\n<li>&quot;It's probably a caching issue&quot;</li>\n<li>&quot;Must be a race condition&quot;</li>\n<li>&quot;The database is slow again&quot;</li>\n</ul>\n<p>Sometimes it is. Often it isn't.</p>\n<h3>The Closed Mind</h3>\n<p>Once you form a theory, you start seeing evidence that supports it and ignoring evidence that doesn't. Stay open to being wrong.</p>\n<h2>Advanced Techniques</h2>\n<h3>The Rubber Duck Method</h3>\n<p>Explain the problem out loud to an inanimate object. You'll often solve it before you finish talking.</p>\n<h3>The Binary Search</h3>\n<p>If something worked yesterday but not today, binary search through the changes:</p>\n<ol>\n<li>Find the midpoint between &quot;working&quot; and &quot;broken&quot;</li>\n<li>Test that state</li>\n<li>Narrow the range and repeat</li>\n</ol>\n<h3>The Minimal Reproduction</h3>\n<p>Strip away everything non-essential until you have the smallest possible example that demonstrates the bug.</p>\n<h2>The Mindset Shift</h2>\n<p>Great debugging isn't about being smart or knowing obscure tools. It's about being methodical, patient, and curious.</p>\n<p>Think like a detective:</p>\n<ul>\n<li>Follow the evidence, not your assumptions</li>\n<li>Question everything, including your own code</li>\n<li>Look for patterns and anomalies</li>\n<li>Document your investigation</li>\n<li>Consider multiple theories</li>\n</ul>\n<h2>Tools of the Trade</h2>\n<p>My debugging toolkit has evolved over the years:</p>\n<p><strong>For Web Development:</strong></p>\n<ul>\n<li>Browser DevTools (master the Network and Performance tabs)</li>\n<li><code>console.log()</code> (don't be ashamed, it works)</li>\n<li>Debugger statements and breakpoints</li>\n</ul>\n<p><strong>For Backend:</strong></p>\n<ul>\n<li>Structured logging with correlation IDs</li>\n<li>APM tools (New Relic, DataDog)</li>\n<li>Database query analyzers</li>\n</ul>\n<p><strong>For Everything:</strong></p>\n<ul>\n<li>Git bisect (automated binary search)</li>\n<li>Postman/curl for API testing</li>\n<li>A good text editor with search/replace</li>\n</ul>\n<h2>The Satisfaction</h2>\n<p>There's something deeply satisfying about solving a tough bug. It's like completing a puzzle or solving a mystery novel.</p>\n<p>The moment when all the pieces click into place, when you finally understand what went wrong and why - that's what keeps me coming back to this profession.</p>\n<h2>Your Turn</h2>\n<p>What's the most challenging bug you've ever solved? What techniques helped you crack the case?</p>\n<p>Remember: every bug is a mystery waiting to be solved. You just need to think like a detective.</p>\n<p><em>The game is afoot!</em></p>\n",
      "title": "Debugging Like a Detective - The Art of Following Clues",
      "date": "2025-01-29T05:00:00.000Z",
      "description": "Great debugging isn't about tools or techniques - it's about thinking like Sherlock Holmes.",
      "isCompleted": true,
      "slug": "debugging-like-a-detective",
      "tags": [
        "debugging",
        "problem-solving",
        "software",
        "mindset"
      ]
    },
    {
      "body": "<h2>An Introduction</h2>\n<p>Hi, My name Wisdom and after 10 years of being a software developer, I finally decided to build my own site, starting with this blog</p>\n<p>You can read a bit more about me in the <a href=\"/about\">about page</a>.</p>\n<h2>Why A Website</h2>\n<p>Mostly to have somewhere to share some future projects, but also just to prove to myself that I can build, maintain, and learn from doing it.</p>\n<h2>Why A Blog</h2>\n<p>I think of the blog as a way to give back a bit. I've learned so much from the internet in my career,<br>\nbut I've never published anything to help others. I used to think maybe I shouldn't because there is always<br>\nsomeone that knows more than me, but I'm learning that I should anyway because:</p>\n<ul>\n<li><ol>\n<li>There are never enough perspectives on building good software</li>\n</ol></li>\n<li><ol start=\"2\">\n<li>Representation is important, and I like to see black engineers post more, so I should be the future that I want.</li>\n</ol></li>\n<li><ol start=\"3\">\n<li>I legitimately think I will enjoy it, and also learn a lot from it.</li>\n</ol></li>\n<li><ol start=\"4\">\n<li>I feel like the WEB is making a real comeback!</li>\n</ol></li>\n</ul>\n<h2>What To Expect</h2>\n<p>Posts about software, music, tech, and life in general. I want to write about things that I find interesting,<br>\nhonestly, that could be anything.</p>\n<h2>Message To the World</h2>\n<p>Build your own website! It's cool and it's not that hard I promise!</p>\n<p>If I can do it, you can too!</p>\n<p>Thanks for reading!</p>\n",
      "title": "Hello World!",
      "date": "2025-04-21T04:00:00.000Z",
      "description": "After 10 years of being a software developer, I finally decided to build my own site.",
      "isCompleted": true,
      "slug": "hello-world",
      "tags": [
        "self",
        "thoughts"
      ]
    },
    {
      "body": "<h2>The Beat Goes On</h2>\n<p>I've been playing music for almost as long as I've been writing code. Piano since I was 8, guitar since high school, and I've been tinkering with production software for the past few years.</p>\n<p>What I didn't expect was how much these two worlds would influence each other.</p>\n<h2>Patterns Everywhere</h2>\n<p>Music is built on patterns - chord progressions, rhythmic cycles, melodic phrases that repeat and evolve. Code is the same way. We have design patterns, architectural patterns, even naming patterns.</p>\n<p>Both are about taking simple elements and combining them into something complex and beautiful.</p>\n<h3>The 4/4 Time Signature of Programming</h3>\n<p>Most popular music is in 4/4 time - four beats per measure. It's predictable, it's comfortable, and it works.</p>\n<p>Most of my code follows a similar rhythm:</p>\n<ol>\n<li><strong>Setup</strong> - Import dependencies, define constants</li>\n<li><strong>Process</strong> - The main logic, the meat of the function</li>\n<li><strong>Transform</strong> - Manipulate the data</li>\n<li><strong>Return</strong> - Send back the result</li>\n</ol>\n<p>Four beats. Four steps. It's not revolutionary, but it's reliable.</p>\n<h2>When the Music Stops</h2>\n<p>Ever notice how silence in music is just as important as the notes? The space between sounds gives music its shape and meaning.</p>\n<p>Code needs breathing room too. White space, clear separation between concerns, moments where the logic can rest and be understood.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Cramped - hard to read</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">processUser</span>=(<span class=\"hljs-params\">user</span>)=&gt;{<span class=\"hljs-keyword\">if</span>(!user.<span class=\"hljs-property\">email</span>)<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Invalid&#x27;</span>);<span class=\"hljs-keyword\">const</span> normalized=user.<span class=\"hljs-property\">email</span>.<span class=\"hljs-title function_\">toLowerCase</span>();<span class=\"hljs-keyword\">return</span>{...user,<span class=\"hljs-attr\">email</span>:normalized};}\n\n<span class=\"hljs-comment\">// Breathing room - much better</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">processUser</span> = (<span class=\"hljs-params\">user</span>) =&gt; {\n  <span class=\"hljs-keyword\">if</span> (!user.<span class=\"hljs-property\">email</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Invalid email&#x27;</span>);\n  }\n  \n  <span class=\"hljs-keyword\">const</span> normalized = user.<span class=\"hljs-property\">email</span>.<span class=\"hljs-title function_\">toLowerCase</span>();\n  \n  <span class=\"hljs-keyword\">return</span> {\n    ...user,\n    <span class=\"hljs-attr\">email</span>: normalized\n  };\n};\n</code></pre>\n<h2>The Improvisation Mindset</h2>\n<p>Jazz taught me something crucial about problem-solving: sometimes you have to play the &quot;wrong&quot; note to find the right one.</p>\n<p>In code, this means being willing to write messy first drafts. To try approaches that might not work. To refactor ruthlessly when you find a better way.</p>\n<p>The best solos aren't planned - they emerge from understanding the structure well enough to break it creatively.</p>\n<h2>My Coding Playlist</h2>\n<p>What I listen to while programming has evolved over the years:</p>\n<ul>\n<li><strong>Deep Focus</strong>: Ambient electronic (Ã“lafur Arnalds, Nils Frahm)</li>\n<li><strong>Problem Solving</strong>: Instrumental hip-hop (Nujabes, J Dilla)</li>\n<li><strong>Debugging</strong>: Something familiar that won't distract (usually lo-fi playlists)</li>\n<li><strong>Refactoring</strong>: Upbeat but not too complex (Bonobo, Emancipator)</li>\n</ul>\n<h2>The Collaboration Connection</h2>\n<p>Playing in a band teaches you things about teamwork that no Agile methodology can capture:</p>\n<ul>\n<li><strong>Listen more than you play</strong> - In code reviews and in music</li>\n<li><strong>Leave space for others</strong> - Don't over-engineer, don't overplay</li>\n<li><strong>Know when to lead and when to follow</strong> - Sometimes you're the rhythm section, sometimes you're the soloist</li>\n</ul>\n<h2>Finding Your Rhythm</h2>\n<p>Whether you're musical or not, I think there's value in finding the rhythm in your work. The patterns that help you think, the cadences that help you focus, the spaces that help you breathe.</p>\n<p>What does your code sound like? What's its tempo, its key signature, its emotional tone?</p>\n<p>Maybe that sounds abstract, but I think the best programmers are composers at heart - taking disparate elements and arranging them into something that not only works, but feels right.</p>\n<p>What music helps you code? Or do you prefer the sound of silence?</p>\n",
      "title": "The Rhythm of Code - How Music Shapes My Programming",
      "date": "2025-01-08T05:00:00.000Z",
      "description": "Exploring the unexpected connections between musical composition and software architecture.",
      "isCompleted": true,
      "slug": "music-and-code",
      "tags": [
        "music",
        "creativity",
        "productivity",
        "personal"
      ]
    },
    {
      "body": "<h2>The Confession</h2>\n<p>I have a problem. I start side projects like other people start Netflix series - with great enthusiasm and terrible follow-through.</p>\n<p>My GitHub is a graveyard of half-finished ideas, each one representing a weekend of excitement followed by months of neglect.</p>\n<p>Let me give you the tour.</p>\n<h2>The Hall of Abandoned Dreams</h2>\n<h3>TaskMaster Pro (2019)</h3>\n<p><strong>The Idea:</strong> A todo app that would revolutionize productivity by using AI to prioritize tasks.</p>\n<p><strong>What I Built:</strong> A basic CRUD app with a fancy gradient background.</p>\n<p><strong>Why It Died:</strong> Turns out building AI is hard. Also, the world doesn't need another todo app.</p>\n<p><strong>What I Learned:</strong> Validate the problem before building the solution.</p>\n<h3>CoffeeTracker (2020)</h3>\n<p><strong>The Idea:</strong> Track your coffee consumption and find the perfect brewing ratios.</p>\n<p><strong>What I Built:</strong> A React app that could log coffee drinks and show pretty charts.</p>\n<p><strong>Why It Died:</strong> I realized I was the only person obsessive enough about coffee data to use this.</p>\n<p><strong>What I Learned:</strong> Build for a market, not just for yourself.</p>\n<h3>DevMemes (2021)</h3>\n<p><strong>The Idea:</strong> A meme generator specifically for programming jokes.</p>\n<p><strong>What I Built:</strong> A working meme generator with templates and text overlay.</p>\n<p><strong>Why It Died:</strong> Memes are hard to monetize, and I got bored after the initial novelty wore off.</p>\n<p><strong>What I Learned:</strong> Passion projects need sustainable motivation, not just initial excitement.</p>\n<h3>LocalEats (2022)</h3>\n<p><strong>The Idea:</strong> A platform to help people discover local restaurants through community recommendations.</p>\n<p><strong>What I Built:</strong> User authentication, restaurant listings, and a review system.</p>\n<p><strong>Why It Died:</strong> Marketing is harder than coding. I built it, but nobody came.</p>\n<p><strong>What I Learned:</strong> &quot;If you build it, they will come&quot; is a lie.</p>\n<h3>FocusFlow (2023)</h3>\n<p><strong>The Idea:</strong> A Pomodoro timer that adapts to your energy levels throughout the day.</p>\n<p><strong>What I Built:</strong> A beautiful timer with statistics and customizable intervals.</p>\n<p><strong>Why It Died:</strong> I kept tweaking the algorithm instead of shipping. Perfect became the enemy of good.</p>\n<p><strong>What I Learned:</strong> Ship early, iterate based on feedback.</p>\n<h2>The Pattern Recognition</h2>\n<p>Looking back, I see the same patterns in every failure:</p>\n<h3>The Shiny Object Syndrome</h3>\n<p>I'd get excited about a new technology and build a project just to try it out. The tech was the goal, not the product.</p>\n<h3>The Feature Creep</h3>\n<p>Every project started simple but grew complex as I added &quot;just one more feature&quot; before launching.</p>\n<h3>The Solo Act</h3>\n<p>I tried to do everything myself - design, development, marketing, business development. Turns out I'm not good at all of those things.</p>\n<h3>The Perfectionist Trap</h3>\n<p>I'd spend weeks polishing features that nobody would ever use instead of getting feedback from real users.</p>\n<h2>The Survivors</h2>\n<p>Not everything died. A few projects made it past the initial enthusiasm:</p>\n<h3>This Blog</h3>\n<p><strong>Why It Survived:</strong> I kept it simple. No complex features, no grand monetization plans. Just writing.</p>\n<h3>My Dotfiles Repo</h3>\n<p><strong>Why It Survived:</strong> I use it every day. Selfish motivation is powerful motivation.</p>\n<h3>A Simple Expense Tracker</h3>\n<p><strong>Why It Survived:</strong> I built it for my wife, got immediate feedback, and kept it focused on solving one problem well.</p>\n<h2>What I'm Doing Differently Now</h2>\n<h3>Start with the Problem</h3>\n<p>I now spend more time talking to potential users before writing any code. What problem are they actually facing? How are they solving it now?</p>\n<h3>Embrace Constraints</h3>\n<p>I give myself artificial limits:</p>\n<ul>\n<li>One weekend to build an MVP</li>\n<li>No more than 3 core features</li>\n<li>Must be useful to at least 10 people I know personally</li>\n</ul>\n<h3>Ship Ugly</h3>\n<p>My first versions are embarrassingly basic. But they work, and they get feedback.</p>\n<h3>Find Accountability</h3>\n<p>I tell people about my projects now. Public commitment is powerful motivation.</p>\n<h2>The Graveyard's Gift</h2>\n<p>Every failed project taught me something:</p>\n<ul>\n<li>How to use new technologies</li>\n<li>What users actually want (vs. what I think they want)</li>\n<li>The importance of marketing and distribution</li>\n<li>When to pivot and when to persist</li>\n</ul>\n<p>The graveyard isn't a monument to failure - it's a library of lessons.</p>\n<h2>Current Project: Still Breathing</h2>\n<p>I'm working on a simple tool to help developers track their learning goals. It's basic, it's ugly, and I've already shown it to 5 people who said they'd use it.</p>\n<p>Will it join the graveyard? Maybe. But if it does, I'll learn something new to add to the collection.</p>\n<h2>Your Graveyard</h2>\n<p>What's in your side project graveyard? What patterns do you see in your abandoned ideas?</p>\n<p>Share your failures - they're often more instructive than successes.</p>\n<p>And remember: the graveyard isn't the end of the story. It's just the beginning of wisdom.</p>\n<p><em>Here lies another brilliant idea, poorly executed. May it rest in peace and rise as knowledge.</em></p>\n",
      "title": "Welcome to My Side Project Graveyard",
      "date": "2025-02-05T05:00:00.000Z",
      "description": "A tour through my collection of abandoned projects and what I learned from each failure.",
      "isCompleted": true,
      "slug": "side-projects-graveyard",
      "tags": [
        "projects",
        "failure",
        "learning",
        "entrepreneurship"
      ]
    },
    {
      "body": "<h2>Remember When Websites Were Fast?</h2>\n<p>I was browsing some old sites on the Wayback Machine the other day (as one does), and I was struck by how <em>fast</em> everything felt. Pages loaded instantly. Interactions were immediate. The web felt alive.</p>\n<p>Then I opened a modern news site and watched my laptop fan spin up just to read an article.</p>\n<p>Something went wrong along the way. But I think we're finally finding our way back.</p>\n<h2>The Great Bloat</h2>\n<p>Somewhere between jQuery and the modern framework wars, we lost the plot. We started shipping entire application frameworks to display a blog post. We normalized 3MB JavaScript bundles for sites that could have been built with HTML and CSS.</p>\n<p>We convinced ourselves that complexity was sophistication.</p>\n<h3>The Numbers Don't Lie</h3>\n<ul>\n<li>Average webpage size in 2010: ~700KB</li>\n<li>Average webpage size in 2023: ~2.2MB</li>\n<li>JavaScript bundle sizes have grown 10x faster than internet speeds</li>\n</ul>\n<p>We're literally making the web slower while our connections get faster.</p>\n<h2>The Healing Begins</h2>\n<p>But something beautiful is happening. Developers are rediscovering the fundamentals:</p>\n<h3>HTML is Actually Pretty Good</h3>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&lt;!-- This works. It&#x27;s accessible. It&#x27;s fast. --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">details</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">summary</span>&gt;</span>Click to expand<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">summary</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>No JavaScript required!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">details</span>&gt;</span>\n</code></pre>\n<h3>CSS Can Do Almost Everything</h3>\n<p>Modern CSS is incredibly powerful. Grid, flexbox, custom properties, container queries - we can build complex layouts without a single line of JavaScript.</p>\n<h3>Progressive Enhancement is Back</h3>\n<p>Start with HTML that works. Add CSS that makes it beautiful. Sprinkle JavaScript only where it adds real value.</p>\n<h2>The New Minimalists</h2>\n<p>A new generation of developers is embracing simplicity:</p>\n<ul>\n<li><strong>Astro</strong> - Ship less JavaScript by default</li>\n<li><strong>Svelte</strong> - Compile away the framework</li>\n<li><strong>Alpine.js</strong> - jQuery's spiritual successor, but better</li>\n<li><strong>HTMX</strong> - HTML on steroids</li>\n</ul>\n<p>These tools share a philosophy: the web platform is powerful. Let's use it.</p>\n<h2>What I'm Doing Differently</h2>\n<p>This blog is built with SvelteKit, but it could have been built with vanilla HTML. The JavaScript enhances the experience but isn't required for it to work.</p>\n<p>I'm also:</p>\n<ul>\n<li>Optimizing images aggressively</li>\n<li>Inlining critical CSS</li>\n<li>Using system fonts (they're beautiful and free)</li>\n<li>Measuring performance, not just features</li>\n</ul>\n<h2>The Resistance</h2>\n<p>Not everyone is on board. I still see job postings asking for &quot;React experts&quot; to build marketing sites. I still see developers reaching for complex state management libraries to handle a simple form.</p>\n<p>Old habits die hard.</p>\n<h2>Why This Matters</h2>\n<p>Fast websites aren't just nice to have - they're more accessible, more sustainable, and more inclusive. They work on slow connections and old devices. They don't drain batteries or spin up fans.</p>\n<p>They respect users' time and attention.</p>\n<h2>The Path Forward</h2>\n<p>I'm not saying we should abandon modern tools. React, Vue, and Angular have their place. But let's use them intentionally, not reflexively.</p>\n<p>Let's ask &quot;What does this add?&quot; instead of &quot;What's the latest framework?&quot;</p>\n<p>Let's remember that the web's superpower isn't complexity - it's simplicity that scales.</p>\n<h2>A Personal Challenge</h2>\n<p>For my next project, I'm going to try building it with just HTML, CSS, and vanilla JavaScript. No build step, no framework, no dependencies.</p>\n<p>I bet it'll be faster, more maintainable, and more fun than anything I've built in years.</p>\n<p>Want to join me? Let's heal the web, one simple site at a time.</p>\n<p>What's the most over-engineered website you've encountered lately? How would you simplify it?</p>\n",
      "title": "The Web is Healing (And It's About Time)",
      "date": "2025-01-22T05:00:00.000Z",
      "description": "After years of bloated frameworks and over-engineering, the web is remembering what made it great.",
      "isCompleted": true,
      "slug": "the-web-is-healing",
      "tags": [
        "web",
        "frontend",
        "simplicity",
        "performance"
      ]
    }
  ]
}